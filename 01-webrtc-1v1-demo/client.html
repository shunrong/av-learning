<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC 1v1 è§†é¢‘é€šè¯</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      color: white;
      margin-bottom: 30px;
      font-size: 2em;
    }

    .status {
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .status-item {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
    }

    .status-label {
      font-weight: 600;
      color: #555;
    }

    .status-value {
      color: #667eea;
      font-weight: 500;
    }

    .status-value.connected {
      color: #10b981;
    }

    .status-value.disconnected {
      color: #ef4444;
    }

    /* æ¥ç”µé€šçŸ¥ */
    .incoming-call {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      text-align: center;
      z-index: 1000;
      animation: shake 0.5s infinite;
    }

    .incoming-call.show {
      display: block;
    }

    @keyframes shake {
      0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
      25% { transform: translate(-50%, -50%) rotate(-2deg); }
      75% { transform: translate(-50%, -50%) rotate(2deg); }
    }

    .incoming-call h2 {
      color: #333;
      margin-bottom: 10px;
      font-size: 24px;
    }

    .incoming-call p {
      color: #666;
      margin-bottom: 30px;
      font-size: 18px;
    }

    .call-actions {
      display: flex;
      gap: 20px;
      justify-content: center;
    }

    .accept-btn {
      background: #10b981;
      color: white;
      padding: 15px 40px;
      border: none;
      border-radius: 50px;
      font-size: 18px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s;
    }

    .accept-btn:hover {
      background: #059669;
      transform: scale(1.05);
    }

    .reject-btn {
      background: #ef4444;
      color: white;
      padding: 15px 40px;
      border: none;
      border-radius: 50px;
      font-size: 18px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s;
    }

    .reject-btn:hover {
      background: #dc2626;
      transform: scale(1.05);
    }

    .video-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .video-wrapper {
      background: #000;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      position: relative;
      min-height: 300px;
    }

    .video-label {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 14px;
      z-index: 10;
    }

    video {
      width: 100%;
      height: auto;
      display: block;
      min-height: 300px;
      object-fit: cover;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }

    button {
      padding: 12px 30px;
      font-size: 16px;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: 600;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .main-controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }

    #callBtn {
      background: #10b981;
      color: white;
      font-size: 18px;
      padding: 15px 50px;
    }

    #hangupBtn {
      background: #ef4444;
      color: white;
      font-size: 18px;
      padding: 15px 50px;
    }

    #toggleVideo {
      background: #10b981;
      color: white;
    }

    #toggleVideo.off {
      background: #ef4444;
    }

    #toggleAudio {
      background: #3b82f6;
      color: white;
    }

    #toggleAudio.off {
      background: #ef4444;
    }

    .waiting {
      text-align: center;
      color: white;
      font-size: 18px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      margin-top: 20px;
      display: none;
    }

    .log {
      background: rgba(0, 0, 0, 0.8);
      color: #10b981;
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }

    .log-item {
      margin: 5px 0;
    }

    @media (max-width: 768px) {
      .video-container {
        grid-template-columns: 1fr;
      }
      
      .main-controls {
        flex-direction: column;
      }
      
      #callBtn, #hangupBtn {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ¥ WebRTC 1v1 è§†é¢‘é€šè¯</h1>

    <div class="status">
      <div class="status-item">
        <span class="status-label">é€šè¯çŠ¶æ€:</span>
        <span class="status-value disconnected" id="callStatus">ç©ºé—²</span>
      </div>
      <div class="status-item">
        <span class="status-label">æˆ‘çš„ID:</span>
        <span class="status-value" id="clientId">-</span>
      </div>
      <div class="status-item">
        <span class="status-label">ä¿¡ä»¤æœåŠ¡å™¨:</span>
        <span class="status-value disconnected" id="wsStatus">æœªè¿æ¥</span>
      </div>
      <div class="status-item">
        <span class="status-label">åœ¨çº¿äººæ•°:</span>
        <span class="status-value" id="userCount">0</span>
      </div>
    </div>

    <!-- æ¥ç”µé€šçŸ¥ -->
    <div class="incoming-call" id="incomingCall">
      <h2>ğŸ“ æ¥ç”µ</h2>
      <p id="callerInfo">å¯¹æ–¹æ­£åœ¨å‘¼å«...</p>
      <audio id="ringtone" loop>
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=" type="audio/wav">
      </audio>
      <div class="call-actions">
        <button class="accept-btn" id="acceptBtn">âœ“ æ¥å¬</button>
        <button class="reject-btn" id="rejectBtn">âœ— æ‹’ç»</button>
      </div>
    </div>

    <!-- ä¸»æ§åˆ¶æŒ‰é’® -->
    <div class="main-controls">
      <button id="callBtn">ğŸ“ æ‹¨æ‰“ç”µè¯</button>
      <button id="hangupBtn" style="display: none;">â˜ï¸ æŒ‚æ–­</button>
    </div>

    <!-- è§†é¢‘åŒºåŸŸ -->
    <div class="video-container" id="videoContainer" style="display: none;">
      <div class="video-wrapper">
        <div class="video-label">ğŸ“¹ æˆ‘çš„è§†é¢‘</div>
        <video id="localVideo" autoplay muted playsinline></video>
      </div>
      <div class="video-wrapper">
        <div class="video-label">ğŸ“¹ å¯¹æ–¹è§†é¢‘</div>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>
    </div>

    <!-- åª’ä½“æ§åˆ¶æŒ‰é’® -->
    <div class="controls" id="mediaControls" style="display: none;">
      <button id="toggleVideo">ğŸ“¹ å…³é—­æ‘„åƒå¤´</button>
      <button id="toggleAudio">ğŸ¤ é™éŸ³</button>
    </div>

    <div class="waiting" id="waiting"></div>

    <div class="log" id="log"></div>
  </div>

  <script>
    // ========== å…¨å±€å˜é‡ ==========
    let ws;                          // WebSocket è¿æ¥
    let pc;                          // RTCPeerConnection
    let localStream;                 // æœ¬åœ°åª’ä½“æµ
    let clientId;                    // å®¢æˆ·ç«¯ID
    let callState = 'idle';          // idle | calling | ringing | connected

    // DOM å…ƒç´ 
    const callBtn = document.getElementById('callBtn');
    const hangupBtn = document.getElementById('hangupBtn');
    const incomingCallEl = document.getElementById('incomingCall');
    const acceptBtn = document.getElementById('acceptBtn');
    const rejectBtn = document.getElementById('rejectBtn');
    const ringtone = document.getElementById('ringtone');
    const videoContainer = document.getElementById('videoContainer');
    const mediaControls = document.getElementById('mediaControls');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const callStatusEl = document.getElementById('callStatus');
    const clientIdEl = document.getElementById('clientId');
    const wsStatusEl = document.getElementById('wsStatus');
    const userCountEl = document.getElementById('userCount');
    const waitingEl = document.getElementById('waiting');
    const logEl = document.getElementById('log');
    const toggleVideoBtn = document.getElementById('toggleVideo');
    const toggleAudioBtn = document.getElementById('toggleAudio');

    // ========== é¡µé¢åŠ è½½æ—¶è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨ ==========
    window.onload = () => {
      log('é¡µé¢å·²åŠ è½½ï¼Œç­‰å¾…æ‹¨æ‰“ç”µè¯');
      connectSignaling();
    };

    // ========== æ‹¨æ‰“ç”µè¯ ==========
    callBtn.onclick = async () => {
      try {
        log('=== å‘èµ·å‘¼å« ===');
        callBtn.disabled = true;
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å¯¹æ–¹åœ¨çº¿
        const userCount = parseInt(userCountEl.textContent);
        if (userCount < 2) {
          alert('å¯¹æ–¹ä¸åœ¨çº¿ï¼Œæ— æ³•æ‹¨æ‰“');
          callBtn.disabled = false;
          return;
        }

        // 1. å…ˆè·å–æœ¬åœ°åª’ä½“æµ
        log('æ­£åœ¨è·å–æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™...');
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { width: 1280, height: 720 },
          audio: true
        });
        
        localVideo.srcObject = localStream;
        log('âœ“ æœ¬åœ°åª’ä½“æµè·å–æˆåŠŸ');

        // 2. æ˜¾ç¤ºè§†é¢‘åŒºåŸŸ
        videoContainer.style.display = 'grid';
        mediaControls.style.display = 'flex';
        callBtn.style.display = 'none';
        hangupBtn.style.display = 'block';

        // 3. å‘é€å‘¼å«è¯·æ±‚
        callState = 'calling';
        updateStatus('callStatus', 'å‘¼å«ä¸­...', false);
        
        ws.send(JSON.stringify({
          type: 'call-request',
          from: clientId
        }));
        
        log('âœ“ å‘¼å«è¯·æ±‚å·²å‘é€ï¼Œç­‰å¾…å¯¹æ–¹æ¥å¬...');
        waitingEl.style.display = 'block';
        waitingEl.textContent = 'ç­‰å¾…å¯¹æ–¹æ¥å¬...';

      } catch (error) {
        log('âœ— é”™è¯¯: ' + error.message, 'error');
        alert('æ— æ³•è®¿é—®æ‘„åƒå¤´æˆ–éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
        callBtn.disabled = false;
        resetToIdle();
      }
    };

    // ========== æ¥å¬ç”µè¯ ==========
    acceptBtn.onclick = async () => {
      try {
        log('=== æ¥å¬ç”µè¯ ===');
        
        // 1. åœæ­¢é“ƒå£°
        ringtone.pause();
        ringtone.currentTime = 0;
        
        // 2. éšè—æ¥ç”µé€šçŸ¥
        incomingCallEl.classList.remove('show');
        
        // 3. è·å–æœ¬åœ°åª’ä½“æµ
        log('æ­£åœ¨è·å–æ‘„åƒå¤´å’Œéº¦å…‹é£æƒé™...');
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { width: 1280, height: 720 },
          audio: true
        });
        
        localVideo.srcObject = localStream;
        log('âœ“ æœ¬åœ°åª’ä½“æµè·å–æˆåŠŸ');

        // 4. æ˜¾ç¤ºè§†é¢‘åŒºåŸŸ
        videoContainer.style.display = 'grid';
        mediaControls.style.display = 'flex';
        callBtn.style.display = 'none';
        hangupBtn.style.display = 'block';

        // 5. é€šçŸ¥å¯¹æ–¹æ¥å¬
        ws.send(JSON.stringify({
          type: 'call-accepted',
          from: clientId
        }));
        
        log('âœ“ å·²æ¥å¬ï¼Œé€šçŸ¥å¯¹æ–¹...');
        callState = 'connected';
        updateStatus('callStatus', 'é€šè¯ä¸­', true);

        // 6. åˆ›å»ºè¿æ¥
        await createPeerConnection();
        // è¢«å«æ–¹åˆ›å»º offer
        await createOffer();

      } catch (error) {
        log('âœ— é”™è¯¯: ' + error.message, 'error');
        alert('æ— æ³•è®¿é—®æ‘„åƒå¤´æˆ–éº¦å…‹é£');
        rejectCall();
      }
    };

    // ========== æ‹’ç»ç”µè¯ ==========
    rejectBtn.onclick = () => {
      log('=== æ‹’ç»æ¥ç”µ ===');
      rejectCall();
    };

    function rejectCall() {
      // åœæ­¢é“ƒå£°
      ringtone.pause();
      ringtone.currentTime = 0;
      
      // éšè—æ¥ç”µé€šçŸ¥
      incomingCallEl.classList.remove('show');
      
      // é€šçŸ¥å¯¹æ–¹è¢«æ‹’ç»
      ws.send(JSON.stringify({
        type: 'call-rejected',
        from: clientId
      }));
      
      callState = 'idle';
      updateStatus('callStatus', 'ç©ºé—²', false);
      log('âœ“ å·²æ‹’ç»æ¥ç”µ');
    }

    // ========== æŒ‚æ–­ç”µè¯ ==========
    hangupBtn.onclick = () => {
      log('=== æŒ‚æ–­ç”µè¯ ===');
      
      // é€šçŸ¥å¯¹æ–¹æŒ‚æ–­
      ws.send(JSON.stringify({
        type: 'call-ended',
        from: clientId
      }));
      
      endCall();
    };

    function endCall() {
      // 1. åœæ­¢æœ¬åœ°æµ
      if (localStream) {
        localStream.getTracks().forEach(track => {
          track.stop();
          log(`åœæ­¢ ${track.kind} track`);
        });
        localStream = null;
        localVideo.srcObject = null;
      }

      // 2. å…³é—­ PeerConnection
      if (pc) {
        pc.close();
        pc = null;
        log('PeerConnection å·²å…³é—­');
      }

      // 3. æ¸…ç©ºè¿œç¨‹è§†é¢‘
      remoteVideo.srcObject = null;

      // 4. é‡ç½®UI
      resetToIdle();
      
      log('âœ“ é€šè¯å·²ç»“æŸ');
    }

    function resetToIdle() {
      videoContainer.style.display = 'none';
      mediaControls.style.display = 'none';
      callBtn.style.display = 'block';
      hangupBtn.style.display = 'none';
      waitingEl.style.display = 'none';
      
      callBtn.disabled = false;
      callState = 'idle';
      
      updateStatus('callStatus', 'ç©ºé—²', false);
    }

    // ========== è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨ ==========
    function connectSignaling() {
      log('æ­£åœ¨è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨...');
      ws = new WebSocket('ws://localhost:3000');

      ws.onopen = () => {
        log('âœ“ ä¿¡ä»¤æœåŠ¡å™¨è¿æ¥æˆåŠŸ');
        updateStatus('wsStatus', 'å·²è¿æ¥', true);
      };

      ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);
        await handleSignalingMessage(message);
      };

      ws.onerror = (error) => {
        log('âœ— WebSocket é”™è¯¯', 'error');
        updateStatus('wsStatus', 'é”™è¯¯', false);
      };

      ws.onclose = () => {
        log('âœ— ä¿¡ä»¤æœåŠ¡å™¨æ–­å¼€è¿æ¥', 'error');
        updateStatus('wsStatus', 'æ–­å¼€', false);
        
        // å¦‚æœé€šè¯ä¸­æ–­å¼€ï¼Œè‡ªåŠ¨é‡è¿
        if (callState !== 'idle') {
          setTimeout(() => {
            log('å°è¯•é‡æ–°è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨...');
            connectSignaling();
          }, 3000);
        }
      };
    }

    // ========== å¤„ç†ä¿¡ä»¤æ¶ˆæ¯ ==========
    async function handleSignalingMessage(message) {
      log(`æ”¶åˆ°æ¶ˆæ¯: ${message.type}`);

      switch (message.type) {
        case 'connected':
          // æ”¶åˆ°è‡ªå·±çš„å®¢æˆ·ç«¯ID
          clientId = message.clientId;
          clientIdEl.textContent = clientId.substring(0, 8) + '...';
          log(`âœ“ æˆ‘çš„å®¢æˆ·ç«¯ID: ${clientId}`);
          break;

        case 'user-count':
          // æ›´æ–°åœ¨çº¿äººæ•°
          userCountEl.textContent = message.count;
          break;

        case 'call-request':
          // æ”¶åˆ°æ¥ç”µ
          log('ğŸ“ æ”¶åˆ°æ¥ç”µï¼');
          callState = 'ringing';
          updateStatus('callStatus', 'æ¥ç”µä¸­...', false);
          
          // æ˜¾ç¤ºæ¥ç”µé€šçŸ¥
          incomingCallEl.classList.add('show');
          
          // æ’­æ”¾é“ƒå£°
          ringtone.play().catch(e => log('é“ƒå£°æ’­æ”¾å¤±è´¥: ' + e.message));
          break;

        case 'call-accepted':
          // å¯¹æ–¹æ¥å¬äº†
          log('âœ“ å¯¹æ–¹å·²æ¥å¬ï¼');
          callState = 'connected';
          updateStatus('callStatus', 'é€šè¯ä¸­', true);
          waitingEl.style.display = 'none';
          
          // ä¸»å«æ–¹åˆ›å»ºè¿æ¥
          await createPeerConnection();
          break;

        case 'call-rejected':
          // å¯¹æ–¹æ‹’ç»äº†
          log('âœ— å¯¹æ–¹æ‹’ç»äº†é€šè¯');
          alert('å¯¹æ–¹æ‹’ç»äº†é€šè¯');
          endCall();
          break;

        case 'call-ended':
          // å¯¹æ–¹æŒ‚æ–­äº†
          log('âœ— å¯¹æ–¹å·²æŒ‚æ–­');
          alert('å¯¹æ–¹å·²æŒ‚æ–­');
          endCall();
          break;

        case 'offer':
          // æ”¶åˆ° offer
          log('æ”¶åˆ° offer');
          if (!pc) {
            await createPeerConnection();
          }
          await handleOffer(message.offer);
          break;

        case 'answer':
          // æ”¶åˆ° answer
          if (!pc) {
            log('æ”¶åˆ° answerï¼Œä½†è¿æ¥ä¸å­˜åœ¨');
            return;
          }
          log('æ”¶åˆ° answer');
          await handleAnswer(message.answer);
          break;

        case 'ice-candidate':
          // æ”¶åˆ° ICE candidate
          if (!pc) {
            log('æ”¶åˆ° ICE candidateï¼Œä½†è¿æ¥ä¸å­˜åœ¨');
            return;
          }
          await handleIceCandidate(message.candidate);
          break;

        case 'user-left':
          // å¯¹æ–¹ç¦»çº¿
          log('å¯¹æ–¹å·²ç¦»çº¿');
          if (callState !== 'idle') {
            alert('å¯¹æ–¹å·²ç¦»çº¿ï¼Œé€šè¯ç»“æŸ');
            endCall();
          }
          break;
      }
    }

    // ========== åˆ›å»º PeerConnection ==========
    async function createPeerConnection() {
      log('åˆ›å»º RTCPeerConnection...');

      pc = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      });

      // æ·»åŠ æœ¬åœ°æµåˆ°è¿æ¥
      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
          log(`æ·»åŠ æœ¬åœ° ${track.kind} track`);
        });
      }

      // ç›‘å¬ ICE candidate
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          ws.send(JSON.stringify({
            type: 'ice-candidate',
            candidate: event.candidate
          }));
        }
      };

      // æ¥æ”¶è¿œç¨‹æµ
      pc.ontrack = (event) => {
        log('âœ“ æ”¶åˆ°è¿œç¨‹æµ!');
        remoteVideo.srcObject = event.streams[0];
        updateStatus('callStatus', 'é€šè¯ä¸­ï¼ˆå·²è¿æ¥ï¼‰', true);
      };

      // è¿æ¥çŠ¶æ€ç›‘æ§
      pc.onconnectionstatechange = () => {
        log(`è¿æ¥çŠ¶æ€: ${pc.connectionState}`);

        if (pc.connectionState === 'connected') {
          log('âœ“âœ“âœ“ WebRTC è¿æ¥å»ºç«‹æˆåŠŸï¼');
        } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
          log('è¿æ¥æ–­å¼€æˆ–å¤±è´¥');
        }
      };

      log('âœ“ PeerConnection åˆ›å»ºå®Œæˆ');
    }

    // ========== åˆ›å»º Offer ==========
    async function createOffer() {
      if (!pc) return;
      
      log('åˆ›å»º offer...');
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      
      ws.send(JSON.stringify({
        type: 'offer',
        offer: offer
      }));
      
      log('âœ“ offer å·²å‘é€');
    }

    // ========== å¤„ç† Offer ==========
    async function handleOffer(offer) {
      if (!pc) return;
      
      log('å¤„ç† offer...');
      await pc.setRemoteDescription(new RTCSessionDescription(offer));
      
      log('åˆ›å»º answer...');
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      
      ws.send(JSON.stringify({
        type: 'answer',
        answer: answer
      }));
      
      log('âœ“ answer å·²å‘é€');
    }

    // ========== å¤„ç† Answer ==========
    async function handleAnswer(answer) {
      if (!pc) return;
      
      await pc.setRemoteDescription(new RTCSessionDescription(answer));
      log('âœ“ answer å·²è®¾ç½®');
    }

    // ========== å¤„ç† ICE Candidate ==========
    async function handleIceCandidate(candidate) {
      if (!pc) return;
      
      try {
        await pc.addIceCandidate(new RTCIceCandidate(candidate));
      } catch (error) {
        log('âœ— æ·»åŠ  ICE candidate å¤±è´¥: ' + error.message, 'error');
      }
    }

    // ========== åˆ‡æ¢æ‘„åƒå¤´ ==========
    toggleVideoBtn.onclick = () => {
      if (!localStream) return;
      
      const videoTrack = localStream.getVideoTracks()[0];
      videoTrack.enabled = !videoTrack.enabled;
      
      toggleVideoBtn.textContent = videoTrack.enabled ? 'ğŸ“¹ å…³é—­æ‘„åƒå¤´' : 'ğŸ“¹ å¼€å¯æ‘„åƒå¤´';
      toggleVideoBtn.classList.toggle('off');
      log(videoTrack.enabled ? 'æ‘„åƒå¤´å·²å¼€å¯' : 'æ‘„åƒå¤´å·²å…³é—­');
    };

    // ========== åˆ‡æ¢éº¦å…‹é£ ==========
    toggleAudioBtn.onclick = () => {
      if (!localStream) return;
      
      const audioTrack = localStream.getAudioTracks()[0];
      audioTrack.enabled = !audioTrack.enabled;
      
      toggleAudioBtn.textContent = audioTrack.enabled ? 'ğŸ¤ é™éŸ³' : 'ğŸ¤ å–æ¶ˆé™éŸ³';
      toggleAudioBtn.classList.toggle('off');
      log(audioTrack.enabled ? 'éº¦å…‹é£å·²å¼€å¯' : 'éº¦å…‹é£å·²é™éŸ³');
    };

    // ========== å·¥å…·å‡½æ•° ==========
    function log(message, type = 'info') {
      const time = new Date().toLocaleTimeString();
      const logItem = document.createElement('div');
      logItem.className = 'log-item';
      logItem.style.color = type === 'error' ? '#ef4444' : '#10b981';
      logItem.textContent = `[${time}] ${message}`;
      logEl.appendChild(logItem);
      logEl.scrollTop = logEl.scrollHeight;
      console.log(message);
    }

    function updateStatus(elementId, text, isConnected) {
      const el = document.getElementById(elementId);
      el.textContent = text;
      el.className = 'status-value ' + (isConnected ? 'connected' : 'disconnected');
    }

    // é¡µé¢å…³é—­æ—¶æ¸…ç†èµ„æº
    window.onbeforeunload = () => {
      if (callState !== 'idle') {
        ws.send(JSON.stringify({
          type: 'call-ended',
          from: clientId
        }));
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      if (pc) {
        pc.close();
      }
      if (ws) {
        ws.close();
      }
    };
  </script>
</body>
</html>
