# 视频点播技术详解

## 一、点播 vs 直播

### 核心区别

| 特性 | 点播(VOD) | 直播(Live) |
|------|----------|-----------|
| 内容生成 | 预先录制 | 实时生成 |
| 时间轴 | 可随意控制 | 固定时间线 |
| 访问方式 | 随时观看 | 限定时间 |
| 延迟要求 | 无要求 | 低延迟 |
| 存储 | 必须存储 | 可选存储 |
| 互动性 | 弱 | 强 |

### 应用场景

**点播适用于:**
- 在线课程/培训
- 影视剧平台
- 短视频平台
- 企业培训
- 产品演示

**直播适用于:**
- 体育赛事
- 游戏直播
- 在线会议
- 电商直播
- 演唱会

## 二、视频点播系统架构

### 完整架构图

```
┌─────────────┐
│  用户端     │
│  播放器     │
└──────┬──────┘
       │
       ↓
┌─────────────────────────────────────┐
│           CDN 分发网络               │
│  (内容分发加速，就近访问)             │
└──────────────┬──────────────────────┘
               │
               ↓
┌──────────────────────────────────────┐
│         源站服务器                    │
├──────────────────────────────────────┤
│  ┌────────────┐    ┌──────────────┐ │
│  │ 上传服务   │    │  转码服务    │ │
│  │ (接收文件) │───→│  (FFmpeg)    │ │
│  └────────────┘    └──────┬───────┘ │
│                           │          │
│  ┌────────────┐    ┌──────▼───────┐ │
│  │ 播放服务   │◄───│  存储服务    │ │
│  │ (视频流)   │    │  (OSS/本地)  │ │
│  └────────────┘    └──────────────┘ │
└──────────────────────────────────────┘
```

### 核心组件

#### 1. 上传模块
- 文件分片上传
- 断点续传
- 秒传（Hash去重）
- 上传进度显示

#### 2. 转码模块
- 格式转换
- 多码率生成
- 视频压缩
- 截图/雪碧图生成

#### 3. 存储模块
- 对象存储（OSS）
- 文件系统
- 数据库（元数据）
- 缓存（Redis）

#### 4. 分发模块
- CDN加速
- 负载均衡
- 就近访问
- 带宽优化

#### 5. 播放模块
- 多格式支持
- 自适应码率
- 进度记忆
- 播放统计

## 三、视频编码基础

### 视频编码标准

#### H.264/AVC (2003)
- **优势**: 广泛支持、成熟稳定
- **压缩比**: 中等
- **应用**: Web、移动端、监控
- **专利**: 收费（但浏览器免费）

#### H.265/HEVC (2013)
- **优势**: 压缩率高（比H.264提升50%）
- **劣势**: 编码慢、兼容性差
- **应用**: 4K视频、新设备
- **专利**: 复杂且昂贵

#### VP9 (Google)
- **优势**: 免费开源、压缩率好
- **劣势**: 编码慢
- **应用**: YouTube、Chrome
- **浏览器**: Chrome支持好

#### AV1 (开放媒体联盟)
- **优势**: 免费开源、压缩率最高
- **劣势**: 编码极慢、硬件支持少
- **应用**: 未来趋势
- **浏览器**: 逐步支持中

### 音频编码标准

- **AAC**: 最常用，高质量
- **MP3**: 经典格式，兼容性好
- **Opus**: 开源免费，低延迟
- **Vorbis**: 开源免费，质量好

### 封装格式

| 格式 | 说明 | 视频编码 | 音频编码 |
|-----|------|---------|---------|
| MP4 | 最通用 | H.264/H.265 | AAC |
| WebM | Web专用 | VP8/VP9 | Vorbis/Opus |
| MKV | 功能最强 | 任意 | 任意 |
| FLV | 直播常用 | H.264 | AAC |
| MOV | Apple | H.264 | AAC |

## 四、FFmpeg转码详解

### FFmpeg基本概念

FFmpeg是音视频处理的瑞士军刀，包含：
- **ffmpeg**: 转码工具
- **ffprobe**: 分析工具
- **ffplay**: 播放工具

### 常用转码命令

#### 1. 基础转码
```bash
# 简单转码
ffmpeg -i input.avi output.mp4

# 指定编码器
ffmpeg -i input.avi -c:v libx264 -c:a aac output.mp4
```

#### 2. 控制质量
```bash
# 固定码率(CBR)
ffmpeg -i input.mp4 -b:v 2M -b:a 192k output.mp4

# 固定质量(CRF) - 推荐
ffmpeg -i input.mp4 -c:v libx264 -crf 23 output.mp4
# CRF值: 0-51，越小质量越高，18-28为合理范围
```

#### 3. 改变分辨率
```bash
# 720p
ffmpeg -i input.mp4 -vf scale=1280:720 output.mp4

# 保持宽高比
ffmpeg -i input.mp4 -vf scale=1280:-1 output.mp4
```

#### 4. 生成HLS
```bash
ffmpeg -i input.mp4 \
  -codec: copy \
  -start_number 0 \
  -hls_time 10 \
  -hls_list_size 0 \
  -f hls \
  output.m3u8
```

#### 5. 多码率HLS
```bash
# 生成多个码率版本
ffmpeg -i input.mp4 \
  -filter_complex \
  "[0:v]split=3[v1][v2][v3]; \
   [v1]scale=w=1920:h=1080[v1out]; \
   [v2]scale=w=1280:h=720[v2out]; \
   [v3]scale=w=854:h=480[v3out]" \
  -map "[v1out]" -c:v:0 libx264 -b:v:0 5M \
  -map "[v2out]" -c:v:1 libx264 -b:v:1 3M \
  -map "[v3out]" -c:v:2 libx264 -b:v:2 1M \
  -map a:0 -c:a aac \
  -f hls -var_stream_map "v:0,a:0 v:1,a:0 v:2,a:0" \
  -master_pl_name master.m3u8 \
  -hls_segment_filename "stream_%v/segment_%03d.ts" \
  stream_%v.m3u8
```

#### 6. 生成缩略图
```bash
# 单张缩略图
ffmpeg -i input.mp4 -ss 00:00:10 -vframes 1 -vf scale=320:180 thumb.jpg

# 雪碧图（多张拼接）
ffmpeg -i input.mp4 -vf "select=not(mod(n\,60)),scale=160:90,tile=10x10" sprite.jpg
```

#### 7. 截取视频片段
```bash
# 从10秒开始，截取30秒
ffmpeg -i input.mp4 -ss 00:00:10 -t 00:00:30 -c copy output.mp4
```

### FFmpeg性能优化

#### 1. 硬件加速

**NVIDIA GPU (NVENC):**
```bash
ffmpeg -hwaccel cuda -i input.mp4 \
  -c:v h264_nvenc -preset fast \
  output.mp4
```

**Intel GPU (Quick Sync):**
```bash
ffmpeg -hwaccel qsv -i input.mp4 \
  -c:v h264_qsv -preset fast \
  output.mp4
```

**Apple M1/M2 (VideoToolbox):**
```bash
ffmpeg -i input.mp4 \
  -c:v h264_videotoolbox -b:v 5M \
  output.mp4
```

#### 2. 多线程
```bash
# 使用多核CPU
ffmpeg -i input.mp4 -threads 8 -c:v libx264 output.mp4
```

#### 3. 预设选择
```bash
# x264预设: ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow
# 越慢压缩率越高但耗时越长
ffmpeg -i input.mp4 -c:v libx264 -preset fast output.mp4
```

## 五、HLS技术深入

### HLS协议结构

#### M3U8播放列表

**简单播放列表:**
```m3u8
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:0

#EXTINF:10.0,
segment_0.ts
#EXTINF:10.0,
segment_1.ts
#EXTINF:10.0,
segment_2.ts
#EXT-X-ENDLIST
```

**主播放列表（多码率）:**
```m3u8
#EXTM3U
#EXT-X-VERSION:3

# 1080p 5Mbps
#EXT-X-STREAM-INF:BANDWIDTH=5000000,RESOLUTION=1920x1080
stream_high.m3u8

# 720p 3Mbps
#EXT-X-STREAM-INF:BANDWIDTH=3000000,RESOLUTION=1280x720
stream_medium.m3u8

# 480p 1Mbps
#EXT-X-STREAM-INF:BANDWIDTH=1000000,RESOLUTION=854x480
stream_low.m3u8
```

### HLS关键参数

| 参数 | 说明 | 推荐值 |
|-----|------|--------|
| 切片时长 | 每个TS文件的时长 | 6-10秒 |
| 播放列表大小 | 保留多少个切片 | 3-6个 |
| 目标码率 | 视频码率 | 根据分辨率 |
| 关键帧间隔 | GOP大小 | 等于切片时长 |

### 自适应码率切换

#### 工作原理

1. 客户端测量当前网络带宽
2. 选择合适的码率版本
3. 下载对应的TS切片
4. 网络变化时切换码率

#### 码率梯度设计

**常见配置:**
```
1080p  @ 5 Mbps
720p   @ 3 Mbps
480p   @ 1.5 Mbps
360p   @ 0.8 Mbps
```

**4K场景:**
```
2160p  @ 15 Mbps
1080p  @ 8 Mbps
720p   @ 4 Mbps
480p   @ 2 Mbps
```

## 六、存储策略

### 存储方案对比

#### 1. 本地存储
- **优势**: 简单、无额外成本
- **劣势**: 扩展性差、无法CDN
- **适用**: 学习、小规模

#### 2. 对象存储(OSS)
- **优势**: 可扩展、高可用、便宜
- **劣势**: 需要配置、有成本
- **适用**: 生产环境

**主流OSS服务:**
- 阿里云OSS
- 腾讯云COS
- AWS S3
- 七牛云Kodo

#### 3. 分布式存储
- **优势**: 高性能、高可靠
- **劣势**: 复杂、成本高
- **适用**: 大规模平台

### 目录结构设计

```
media/
├── videos/              # 原始视频
│   ├── {uuid}.mp4
│   └── {uuid}.mov
├── hls/                 # HLS切片
│   └── {uuid}/
│       ├── master.m3u8  # 主播放列表
│       ├── 1080p/
│       │   ├── playlist.m3u8
│       │   └── segment_*.ts
│       ├── 720p/
│       └── 480p/
├── thumbnails/          # 缩略图
│   ├── {uuid}.jpg
│   └── {uuid}_sprite.jpg
└── metadata/            # 元数据
    └── videos.json
```

### 元数据设计

```json
{
  "id": "uuid",
  "title": "视频标题",
  "description": "描述",
  "uploadTime": "2024-01-01T00:00:00Z",
  "duration": 120.5,
  "size": 52428800,
  "status": "ready",
  "formats": {
    "original": {
      "url": "/media/videos/uuid.mp4",
      "codec": "h264",
      "resolution": "1920x1080",
      "bitrate": 5000000
    },
    "hls": {
      "url": "/media/hls/uuid/master.m3u8",
      "variants": [
        {
          "resolution": "1920x1080",
          "bitrate": 5000000,
          "url": "/media/hls/uuid/1080p/playlist.m3u8"
        }
      ]
    }
  },
  "thumbnail": "/media/thumbnails/uuid.jpg"
}
```

## 七、前端播放器

### Video.js集成

```javascript
// 引入Video.js
<link href="https://vjs.zencdn.net/8.0.4/video-js.css" rel="stylesheet" />
<script src="https://vjs.zencdn.net/8.0.4/video.min.js"></script>

// 创建播放器
const player = videojs('my-video', {
  controls: true,
  autoplay: false,
  preload: 'auto'
});

// 播放HLS
player.src({
  type: 'application/x-mpegURL',
  src: 'https://example.com/video.m3u8'
});
```

### hls.js集成（本项目使用）

```javascript
if (Hls.isSupported()) {
  const hls = new Hls({
    debug: false,
    enableWorker: true,
    lowLatencyMode: false
  });
  
  hls.loadSource('video.m3u8');
  hls.attachMedia(video);
  
  hls.on(Hls.Events.MANIFEST_PARSED, () => {
    video.play();
  });
}
```

### 播放控制

```javascript
// 播放/暂停
video.play();
video.pause();

// 跳转到指定时间
video.currentTime = 60; // 跳转到60秒

// 音量控制
video.volume = 0.5; // 0.0 - 1.0
video.muted = true;

// 倍速播放
video.playbackRate = 1.5; // 1.5倍速

// 全屏
video.requestFullscreen();
```

### 事件监听

```javascript
// 可以播放
video.addEventListener('canplay', () => {
  console.log('视频可以播放');
});

// 播放中
video.addEventListener('playing', () => {
  console.log('正在播放');
});

// 暂停
video.addEventListener('pause', () => {
  console.log('已暂停');
});

// 播放进度
video.addEventListener('timeupdate', () => {
  console.log('当前时间:', video.currentTime);
});

// 播放结束
video.addEventListener('ended', () => {
  console.log('播放结束');
});

// 错误
video.addEventListener('error', (e) => {
  console.error('播放错误:', e);
});
```

## 八、性能优化

### 转码优化

1. **选择合适的编码参数**
   - CRF模式优于固定码率
   - 合理选择预设(preset)
   - 使用硬件加速

2. **异步处理**
   - 上传和转码分离
   - 使用消息队列
   - 多任务并行

3. **智能转码**
   - 只转码必要的格式
   - 延迟转码（按需转码）
   - 缓存转码结果

### 播放优化

1. **CDN加速**
   - 使用CDN分发
   - 配置缓存策略
   - 就近访问节点

2. **预加载策略**
   - 预加载下一个切片
   - 缩略图懒加载
   - 首屏优先加载

3. **自适应码率**
   - 根据网络自动切换
   - 平滑过渡
   - 缓冲区管理

### 存储优化

1. **冷热分离**
   - 热门视频放SSD
   - 冷门视频放HDD/归档
   - 自动迁移策略

2. **压缩与去重**
   - 相同视频不重复存储
   - Hash去重
   - 增量存储

## 九、安全措施

### 防盗链

```javascript
// URL签名
const crypto = require('crypto');

function generateSecureUrl(videoPath, secret, expireTime) {
  const timestamp = Date.now() + expireTime;
  const hash = crypto
    .createHash('md5')
    .update(`${videoPath}${secret}${timestamp}`)
    .digest('hex');
  
  return `${videoPath}?token=${hash}&expire=${timestamp}`;
}
```

### HLS加密

```bash
# 生成密钥
openssl rand 16 > enc.key

# 加密转码
ffmpeg -i input.mp4 \
  -hls_key_info_file key_info.txt \
  -hls_time 10 \
  -hls_list_size 0 \
  output.m3u8
```

### 访问控制

- Token验证
- IP白名单
- Referer检查
- 用户认证

## 十、实战案例

### 案例1: 在线教育平台

**需求:**
- 大量课程视频
- 不同网络环境学生
- 防止视频下载
- 观看进度记录

**方案:**
- 转码为多码率HLS
- HLS-AES加密
- Token防盗链
- 进度存储在数据库

### 案例2: 短视频平台

**需求:**
- 快速上传
- 快速播放
- 高并发
- 省带宽

**方案:**
- 分片上传
- 转码为MP4+HLS
- CDN全站加速
- 智能压缩

### 案例3: 企业培训系统

**需求:**
- 内部使用
- 高清画质
- 快速转码
- 低成本

**方案:**
- 内网部署
- GPU硬件加速转码
- NAS存储
- 原始格式播放

## 十一、总结

### 技术栈选择

| 场景 | 推荐方案 |
|-----|---------|
| 小规模学习 | 本地存储 + FFmpeg + HLS |
| 中等规模 | OSS + FFmpeg + CDN |
| 大规模平台 | 分布式存储 + 转码集群 + 全球CDN |

### 关键指标

- **转码速度**: 应快于视频时长
- **首屏时间**: < 2秒
- **卡顿率**: < 1%
- **成功率**: > 99%

### 持续学习

- 关注新编码标准（AV1、VVC）
- 学习视频AI处理
- 了解边缘计算
- 研究WebRTC+VOD混合

---

通过本项目的实践，你应该掌握了视频点播的核心技术和实现方法。继续探索和优化，创建更强大的视频系统！

