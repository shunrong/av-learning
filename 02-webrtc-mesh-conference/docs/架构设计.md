# WebRTC 多人会议架构设计文档

## 🎯 设计目标

1. **可维护性**: 代码清晰，职责分明
2. **可扩展性**: 易于添加新功能
3. **可测试性**: 模块独立，便于单元测试
4. **高内聚低耦合**: 模块间通过事件通信

## 🏗️ 架构分层

```
┌─────────────────────────────────────────┐
│           应用层 (App Layer)            │
│  ┌─────────────────────────────────┐   │
│  │      app.js (应用入口)          │   │
│  │  - 组装所有模块                  │   │
│  │  - 处理业务逻辑                  │   │
│  │  - 连接各模块事件                │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
              ↓ 依赖
┌─────────────────────────────────────────┐
│         协调层 (Coordination)           │
│  ┌─────────────────────────────────┐   │
│  │   RoomClient (房间客户端)       │   │
│  │  - 协调各模块                    │   │
│  │  - 管理房间状态                  │   │
│  │  - 处理 WebRTC 连接逻辑          │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
              ↓ 依赖
┌─────────────────────────────────────────┐
│         功能层 (Feature Layer)          │
│  ┌──────────────┐  ┌──────────────┐   │
│  │ Signaling    │  │ Media        │   │
│  │ Client       │  │ Manager      │   │
│  └──────────────┘  └──────────────┘   │
│  ┌──────────────┐  ┌──────────────┐   │
│  │ PeerConn     │  │ UI           │   │
│  │ Manager      │  │ Controller   │   │
│  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────┘
              ↓ 依赖
┌─────────────────────────────────────────┐
│        基础层 (Infrastructure)          │
│  ┌──────────────┐  ┌──────────────┐   │
│  │ EventEmitter │  │ Logger       │   │
│  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────┘
```

## 📦 模块职责矩阵

| 模块 | 职责 | 依赖 | 输入 | 输出 |
|------|------|------|------|------|
| **EventEmitter** | 事件系统基类 | 无 | - | 事件发布/订阅能力 |
| **Logger** | 日志工具 | 无 | 日志消息 | 控制台输出 |
| **SignalingClient** | WebSocket 通信 | EventEmitter | 信令消息 | 连接事件 |
| **MediaManager** | 媒体流管理 | EventEmitter | 约束条件 | MediaStream |
| **PeerConnectionManager** | PC 连接池 | EventEmitter | 用户ID, 流 | PC 实例 |
| **UIController** | UI 渲染 | 无 | 数据 | DOM 更新 |
| **RoomClient** | 核心协调器 | 上述所有 | 房间信息 | 业务事件 |
| **App** | 应用入口 | RoomClient, UI | 用户操作 | 完整应用 |

## 🔄 数据流设计

### 1. 用户加入房间流程

```
用户操作                 App                 RoomClient
   │                      │                      │
   │──── 点击加入 ────→   │                      │
   │                      │─ joinRoom() ────→   │
   │                      │                      │
   │                      │                      ├─→ SignalingClient
   │                      │                      │   ↓ connect()
   │                      │                      │   ↓ joinRoom()
   │                      │                      │
   │                      │                      ├─→ MediaManager
   │                      │                      │   ↓ getLocalMedia()
   │                      │                      │
   │                      │   ← room-joined ─   │
   │   ← 显示会议界面 ─   │                      │
```

### 2. 建立 P2P 连接流程

```
RoomClient A          PeerConnManager A      Signal      PeerConnManager B         RoomClient B
     │                       │                  │                │                      │
     │─ user-joined ───→    │                  │                │                      │
     │                       │                  │                │                      │
     │                       │─ createPC() ────→│                │                      │
     │                       │─ createOffer() ──→                │                      │
     │                       │                  │                │                      │
     │                       │─── offer ───────────────────────→ │                      │
     │                       │                  │                │─ setRemoteDesc() ──→ │
     │                       │                  │                │─ createAnswer() ────→│
     │                       │                  │                │                      │
     │                       │ ←──── answer ────────────────────│                      │
     │                       │─ setRemoteDesc() ←               │                      │
     │                       │                  │                │                      │
     │                       │←→── ice-candidates ←→            │                      │
     │                       │                  │                │                      │
     │                       │═══════ connected ═══════════════ │                      │
     │ ← remote-track ──    │                  │                │   ── remote-track →  │
```

## 🎨 设计模式应用

### 1. **发布-订阅模式** (EventEmitter)

**优点**：
- 解耦模块间依赖
- 支持一对多通信
- 易于扩展

**示例**：
```javascript
// 发布者
class SignalingClient extends EventEmitter {
  handleMessage(message) {
    this.emit('user-joined', message);
  }
}

// 订阅者
roomClient.signaling.on('user-joined', (data) => {
  this._connectToUser(data.userId);
});
```

### 2. **单例模式** (Logger)

**优点**：
- 全局统一的日志配置
- 避免多次实例化

**示例**：
```javascript
export const logger = new Logger();
```

### 3. **工厂模式** (PeerConnectionManager)

**优点**：
- 统一创建 PC 实例
- 集中管理配置

**示例**：
```javascript
createPeerConnection(userId) {
  const pc = new RTCPeerConnection(this.config);
  // 统一配置
  pc.onicecandidate = ...
  pc.ontrack = ...
  return pc;
}
```

### 4. **策略模式** (MediaManager)

**优点**：
- 支持不同的媒体获取策略
- 易于切换策略

**示例**：
```javascript
async getLocalMedia() { /* 摄像头策略 */ }
async getScreenShare() { /* 屏幕共享策略 */ }
```

## 🔐 状态管理

### 1. RoomClient 状态机

```
┌──────┐   joinRoom()   ┌────────────┐
│ Idle │─────────────→  │ Connecting │
└──────┘                └────────────┘
                              │
                              │ room-joined
                              ↓
                        ┌───────────┐
                        │ Connected │
                        └───────────┘
                              │
                              │ leaveRoom()
                              ↓
                        ┌──────┐
                        │ Idle │
                        └──────┘
```

### 2. PeerConnection 状态

```
new → checking → connected → disconnected
                     ↓             ↓
                  completed    → failed
```

## 🛡️ 错误处理策略

### 1. 分层错误处理

```
应用层: 用户友好的错误提示
   ↓
协调层: 业务逻辑错误处理
   ↓
功能层: 技术错误捕获和记录
   ↓
基础层: 异常捕获和日志
```

### 2. 错误恢复机制

```javascript
// 示例: SignalingClient 自动重连
_attemptReconnect() {
  if (this.reconnectAttempts < this.maxReconnectAttempts) {
    setTimeout(() => this.connect(), this.reconnectDelay);
  } else {
    this.emit('reconnect-failed');
  }
}
```

## 📊 性能优化设计

### 1. 事件节流

```javascript
// 避免频繁触发 UI 更新
const throttledUpdate = throttle(() => {
  this.ui.updateUserList();
}, 100);
```

### 2. 连接池管理

```javascript
// 复用 PeerConnection
this.peerConnections = new Map();

// 及时清理
closePeerConnection(userId) {
  const pc = this.peerConnections.get(userId);
  pc?.close();
  this.peerConnections.delete(userId);
}
```

### 3. 待处理队列

```javascript
// 缓存 ICE 候选者
this.pendingCandidates = new Map();

// 批量处理
if (this.pendingCandidates.has(userId)) {
  const candidates = this.pendingCandidates.get(userId);
  for (const candidate of candidates) {
    await pc.addIceCandidate(candidate);
  }
}
```

## 🧪 可测试性设计

### 1. 依赖注入

```javascript
class RoomClient {
  constructor(signalingUrl, config = {}) {
    // 可注入配置，便于测试
    this.config = config;
  }
}
```

### 2. Mock 友好的接口

```javascript
class SignalingClient {
  // 可被 mock 的方法
  send(type, data) { ... }
  
  // 测试时可以直接触发
  _handleMessage(message) { ... }
}
```

### 3. 单元测试示例

```javascript
// 测试 EventEmitter
describe('EventEmitter', () => {
  it('should emit events correctly', () => {
    const emitter = new EventEmitter();
    let called = false;
    
    emitter.on('test', () => { called = true; });
    emitter.emit('test');
    
    expect(called).toBe(true);
  });
});
```

## 🔧 扩展性设计

### 1. 插件化架构

```javascript
// 未来可扩展为插件系统
class RoomClient {
  constructor() {
    this.plugins = [];
  }
  
  use(plugin) {
    plugin.install(this);
    this.plugins.push(plugin);
  }
}
```

### 2. 配置驱动

```javascript
const config = {
  iceServers: [...],
  mediaConstraints: {...},
  logLevel: 'DEBUG'
};
```

### 3. 抽象接口

```javascript
// 定义统一接口
class BaseMediaProvider {
  async getMedia(constraints) { throw new Error('Not implemented'); }
}

class WebcamProvider extends BaseMediaProvider {
  async getMedia(constraints) { 
    return navigator.mediaDevices.getUserMedia(constraints);
  }
}
```

## 📐 关键设计决策

### 1. 为什么使用 EventEmitter？

**原因**：
- ✅ 解耦模块依赖
- ✅ 支持异步通信
- ✅ 易于扩展监听器

**替代方案对比**：
- ❌ 直接回调：强耦合，难以维护
- ❌ Promise：不适合一对多通信
- ❌ 观察者模式：与 EventEmitter 类似，但实现更复杂

### 2. 为什么将 PeerConnection 管理独立？

**原因**：
- ✅ 职责单一
- ✅ 便于复用和测试
- ✅ 集中管理连接池

### 3. 为什么 RoomClient 作为协调器？

**原因**：
- ✅ 提供统一的 API 接口
- ✅ 封装复杂的协调逻辑
- ✅ 便于上层调用

## 🎓 学习要点

### 从 01 到 02 的进化

| 方面 | 01 (1v1) | 02 (多人) |
|------|----------|-----------|
| **代码组织** | 单文件 | 模块化 |
| **连接数** | 1 个 PC | N-1 个 PC |
| **状态管理** | 简单变量 | 状态机 |
| **错误处理** | 基础 try-catch | 分层处理 |
| **可扩展性** | 低 | 高 |

### 核心收获

1. ✅ **模块化设计**的重要性
2. ✅ **事件驱动**架构的优势
3. ✅ **单一职责**原则的实践
4. ✅ **状态管理**的必要性
5. ✅ **错误处理**的系统化

## 🚀 下一步

### 可以扩展的功能

1. **DataChannel 聊天**
   - 新增 `ChatManager` 模块
   - 实现文本消息、文件传输

2. **屏幕共享**
   - 扩展 `MediaManager`
   - 添加轨道替换逻辑

3. **会议录制**
   - 新增 `RecordManager` 模块
   - 使用 MediaRecorder API

4. **美颜滤镜**
   - 新增 `FilterManager` 模块
   - 使用 Canvas 处理视频帧

### 向 SFU 架构演进

当参与人数增加时，需要考虑：
- 服务端媒体转发
- Simulcast 支持
- 带宽管理
- 使用 mediasoup 等成熟方案

---

**设计思想**: "高内聚、低耦合、易扩展、可测试"

